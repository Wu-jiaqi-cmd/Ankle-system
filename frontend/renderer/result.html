<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
  <title>评估结果</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">
  <style>
    #videoBox{width:400px;height:225px;position:relative;}
    canvas{position:absolute;top:0;left:0;}
  </style>
</head>
<body class="p-4">
  <h3>风险评估结果</h3>
  <a class="btn btn-sm btn-secondary" href="dashboard.html">返回上传</a>

  <div class="row mt-3">
    <div class="col-md-6">
      <h5>视频回放（含骨架）</h5>
      <div id="videoBox" class="border rounded">
        <video id="video" width="100%" height="100%" controls></video>
        <canvas id="canvas" width="400" height="225"></canvas>
      </div>
    </div>
    <div class="col-md-6">
      <h5>评估信息</h5>
      <ul class="list-group">
        <li class="list-group-item"><strong>分数：</strong><span id="score"></span></li>
        <li class="list-group-item"><strong>风险等级：</strong><span id="risk"></span></li>
        <li class="list-group-item"><strong>运动建议：</strong><span id="advice"></span></li>
      </ul>
    </div>
  </div>

  <script>
    // ① 调试信息
    console.log('>>> location.search', location.search);
    const params = new URLSearchParams(location.search);
    const rawPath = params.get('video');
    console.log('>>> rawPath', rawPath);

    // ② 万能路径（不截断）
    const videoSrc = rawPath ? `http://127.0.0.1:5000${rawPath}` : '';

    // ③ 填充结果
    document.getElementById('score').textContent = params.get('score') || '无';
    document.getElementById('risk').textContent = params.get('risk') || '无';
    document.getElementById('advice').textContent = params.get('advice') || '无';

    // ④ 强制加载+错误捕获
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    if (videoSrc) {
      video.src = videoSrc + '?t=' + Date.now();
      video.load();
      video.play().catch(e => console.error('>>> 播放失败', e));
      video.onloadeddata = drawSkeleton;
    } else {
      console.error('>>> 未收到视频路径');
    }

    async function drawSkeleton() {
      const mpPose = await import('https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469407/pose_wasm.js');
      const pose = new mpPose.Pose({locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469407/${file}`});
      pose.setOptions({modelComplexity: 1, smoothLandmarks: true,
                       minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
      pose.onResults(onResults);

      async function detect() {
        if (video.videoWidth === 0) return;
        await pose.send({image: video});
        requestAnimationFrame(detect);
      }
      detect();
    }

    function onResults(results) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
      if (results.poseLandmarks) {
        mp.drawConnectors(ctx, results.poseLandmarks, mp.POSE_CONNECTIONS, {color: '#00FF00'});
        mp.drawLandmarks(ctx, results.poseLandmarks, {color: '#FF0000', fillColor: '#FF0000'});
        const lm = results.poseLandmarks;
        const heel = {x: lm[30].x * 400, y: lm[30].y * 225};
        const ankle = {x: lm[28].x * 400, y: lm[28].y * 225};
        const toe = {x: lm[32].x * 400, y: lm[32].y * 225};
        const ang = Math.abs(Math.atan2(toe.y - ankle.y, toe.x - ankle.x) -
                             Math.atan2(heel.y - ankle.y, heel.x - ankle.x)) * 180 / Math.PI;
        ctx.fillStyle = '#FFFF00'; ctx.font = '16px Arial';
        ctx.fillText(`背屈角度: ${ang.toFixed(1)}°`, 10, 25);
      }
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.5.1675469407/drawing_utils.js"></script>
</body>
</html>
